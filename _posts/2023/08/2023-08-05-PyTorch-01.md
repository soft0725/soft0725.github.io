---
title: PyTorch 기초 - Numpy와 유사한 기능 
date: '2023-08-05 13:39:00 +0900'
categories: [DeepLearning, PyTorch]
tags: [PyTorch]
math: true
---

원래는 numpy를 먼저 정리해야하는데 그냥 PyTorch부터 정리하겠다.  


## numpy와 닮은 PyTorch 

```python 
import torch # 파이토치를 임포트한다. 

a = torch.tensor([1, 2, 3, 4]) # 1, 2, 3, 4 라는 텐서를 만든다. 
print(a) 
print(type(a))
print(a.dtype)
print(a.shape)

b = torch.tensor([1, 2, 3.1, 4]) # 위 텐서와 다르게 실수가 들어가있다. 
print(b.dtype)
print(b)
```

```
tensor([1, 2, 3, 4])
<class 'torch.Tensor'>
torch.int64
torch.Size([4])
torch.float32
tensor([1.0000, 2.0000, 3.1000, 4.0000])
```
type은 torch.tensor이며, dtype은 a와 b가 다른 모습을 볼 수 있다.  
정수만 들어있는 a의 경우 int64, 실수가 하나라도 들어있는 b의 경우 float32를 볼 수 있다.  


<br>

```python 
A = torch.tensor([ [1,2,3], [3,4,5] ])
# A = torch.tensor([[1,2],[3,4,5]]) # 리스트와는 달리 이제는 행렬이라서 각 행에 해당하는 숫자의 개수가 같아야 함
print(A)
print(A.shape)
print(A.ndim)  # 차원의 수
print(A.numel()) # 전체 성분의 수
```
```
tensor([[1, 2, 3],
        [3, 4, 5]])
torch.Size([2, 3])
2
6
```
주석인 A가 실행이 되지 않는 이유는 행렬이라서 각 행에 해당하는 숫자의 개수가 같아야하는데 2, 3 이라서 안되는 것이다.  
그리고 ndim을 눈으로 가장 쉽게확인하는 방법은 torch.tensor에서 대괄호가 몇갠지 보면 된다.  
마지막으로 numel()은 전체 성분의 수를 알려준다.  


<br>

```python 
print(torch.zeros(5))
print(torch.zeros_like(A))
print(torch.ones(5))
print(torch.zeros(3,3))
print(torch.arange(3,10,2)) # range랑 같은데 tensor로 만들어줌
print(torch.arange(0,1,0.1)) # 소수점 가능
print(torch.linspace(0,1,10)) # 0 에서부터 1 포함 10개로
```

```
tensor([0., 0., 0., 0., 0.])
tensor([[0, 0, 0],
        [0, 0, 0]])
tensor([1., 1., 1., 1., 1.])
tensor([[0., 0., 0.],
        [0., 0., 0.],
        [0., 0., 0.]])
tensor([3, 5, 7, 9])
tensor([0.0000, 0.1000, 0.2000, 0.3000, 0.4000, 0.5000, 0.6000, 0.7000, 0.8000,
        0.9000])
tensor([0.0000, 0.1111, 0.2222, 0.3333, 0.4444, 0.5556, 0.6667, 0.7778, 0.8889,
        1.0000])
```

zeros, ones arange, linspace는 모두 numpy의 기능과 똑같다.  
linspace는 보이는것 처럼 텐서의 값이 일정하다는 것이 특징이다.  

<br>

```python
a = torch.tensor([1,2,3])
b = torch.tensor([4,5,6])
c = a + b
print(c)
```
```
tensor([5, 7, 9])
```
그냥 [1+4, 2+5, 3+6]을 한 것이다. 

<br>

```python 
A = torch.tensor([[1,2,3],[1,2,3]])
B = torch.tensor([[4,5,6],[1,1,1]])
C = A + B
D = A - B

print(C) 
print(D)
print()
print(A*B) # 곱셈은? 성분끼리의 곱! (Hadamard product)
print(A/B) # 나누기도 마찬가지
print(B**2) # 제곱도 각 성분에 대해서 해준다
```
```
tensor([[5, 7, 9],
        [2, 3, 4]])
tensor([[-3, -3, -3],
        [ 0,  1,  2]])

tensor([[ 4, 10, 18],
        [ 1,  2,  3]])
tensor([[0.2500, 0.4000, 0.5000],
        [1.0000, 2.0000, 3.0000]])
tensor([[16, 25, 36],
        [ 1,  1,  1]])
```
덧셈과 뺄셈은 위에서 한 것과 똑같다.  
그리고 아래 곱셈이 있는데 저 곱셈은 성분끼리의 곱이기 때문에 행렬곱이 아니다.  
일반적인 곱셈은 *을 사용하고 행렬곱에서는 @을 사용한다.  

<br>

```python
A=torch.tensor([[1,2],[3,4]])
B=torch.tensor([[1,2],[3,4]])
print(A*B)
print(A@B) # 이게 진짜 행렬 곱
```
```
tensor([[ 1,  4],
        [ 9, 16]])
tensor([[ 7, 10],
        [15, 22]])
```